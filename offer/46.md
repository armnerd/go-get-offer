# 把数字翻译成字符串

## 题目

有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'
现在给一串数字，返回有多少种可能的译码结果

进阶：空间复杂度 O(n)，时间复杂度 O(n)

## 示例

输入："12"
返回值：2
说明：2种可能的译码结果（”ab” 或”l”）

## 思路

> 动态规划

* dp[i] 表示字符串nums中以i个位置结尾的前缀字符串的解码种数
* 当前字符不等于 0 的时候, dp[i] = dp[i-1], 然后解码当前位置字符
* 当前字符加上前一个字符如果是 10 到 26 之间 [包括 10 和 16] 就符合两个合并一起译码的条件
    * 若此时 i 等于 1，直接 dp[i]++
    * 大于 1, 则 dp[i] += dp[i-2]

## 实现

```go
func solve(nums string) int {
	if len(nums) == 0 || nums[0] == '0' {
		return 0
	}
	dp := make([]int, len(nums))
	dp[0] = 1
	for i := 1; i < len(nums); i++ {
		if nums[i] != '0' {
			// 当前字符不等于 0 的时候, 至少有 dp[i-1] 种解法
			dp[i] = dp[i-1]
		}
		// 当前字符加上前一个字符如果是 10 到 26 之间 [包括 10 和 26] 就符合两个合并一起译码的条件
		num := (nums[i-1]-'0')*10 + (nums[i] - '0')
		if num >= 10 && num <= 26 {
			if i == 1 {
				// 若此时 i 等于 1，直接 dp[i]++
				dp[i] += 1
			} else {
				// 大于 1, 就需要加上 dp[i-2] 的结果
				dp[i] += dp[i-2]
			}
		}
	}
	return dp[len(nums)-1]
}
```