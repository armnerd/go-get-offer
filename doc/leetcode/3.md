# 无重复字符的最长子串

## 题目

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。

## 示例

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是子串的长度，"pwke" 是一个子序列，不是子串。
```

## 思路

> 滑动窗口

* 粗暴地来说，就是穷举以每个字符为起点所有的无重复子串，然后找到最长的
* 但是这么地一定有重复多余的动作，若下标 k 开始到 k+n 是无重复子串，那么 k+1 开始到 k+n 的子串显然也是不重复的
* 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界
* 在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针
* 但需要保证这两个指针对应的子串中没有重复的字符，这时我们就需要使用一种数据结构来判断是否有重复的字符
* 在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串

## 复杂度

* 时间复杂度：O(N)

## 实现

```go
func lengthOfLongestSubstring(s string) int {
    // 哈希集合，记录每个字符是否出现过
    m := map[byte]int{}
    n := len(s)
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    rk, ans := -1, 0
    for i := 0; i < n; i++ {
        if i != 0 {
            // 左指针向右移动一格，移除一个字符
            delete(m, s[i-1])
        }
        for rk + 1 < n && m[s[rk+1]] == 0 {
            // 不断地移动右指针
            m[s[rk+1]]++
            rk++
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1)
    }
    return ans
}

func max(x, y int) int {
    if x < y {
        return y
    }
    return x
}
```